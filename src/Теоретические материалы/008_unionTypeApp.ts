// ===== Union Types =====

// Union Types позволяют переменной принимать несколько типов значений,
// что полезно для создания гибких и универсальных функций и структур данных.
// Например, функция может принимать параметр, который может быть строкой, числом или булевым значением.
// Это позволяет обрабатывать различные типы данных в одной функции, улучшая её универсальность.
// Также Union Types могут использоваться для обработки ошибок, где ошибка может быть представлена
// либо строкой, либо массивом строк.
// Кроме того, Union Types полезны при работе с объектами, которые могут иметь разные структуры,
// позволяя функции адаптироваться к различным форматам данных.
// Важно использовать проверки типов (type guards) для безопасной работы с Union Types,
// чтобы избежать ошибок во время выполнения.

function logId(id: string | number | boolean) {
	if (typeof id === "string") {
		console.log("ID as string:", id.toUpperCase());
	} else if (typeof id === "number") {
		console.log("ID as number:", id.toFixed(2));
	} else {
		console.log("ID as boolean:", id ? "True" : "False");
	}
}

function logError(err: string | string[]) {
	if (Array.isArray(err)) {
		console.log("Errors:");
		for (const e of err) {
			console.log("-", e);
		}
	} else {
		console.log("Error:", err);
	}
}

function logObject(obj: { a: number } | { b: string }) {
	if ("a" in obj) {
		console.log("Object has property 'a':", obj.a);
	} else {
		console.log("Object has property 'b':", obj.b);
	}
}

logId("user123");
logId(456);
logId(true);

logError("Single error message");
logError(["Error 1", "Error 2", "Error 3"]);

logObject({ a: 10 });
logObject({ b: "Hello" });

// Union Types помогают создавать гибкий и универсальный код,
// обеспечивая безопасность типов и предотвращая ошибки во время выполнения программы.
// Они позволяют обрабатывать различные типы данных в одной функции,
// делая код более адаптивным и удобным для использования в различных сценариях.
// Однако важно использовать проверки типов для безопасной работы с такими типами данных.
// Например, с помощью typeof, instanceof или пользовательских функций проверки типов.
// Это гарантирует, что операции выполняются только с допустимыми типами,
// предотвращая ошибки и обеспечивая надежность кода.
// Например, в функции logId мы используем typeof для определения типа параметра id
// и выполняем соответствующие операции в зависимости от его типа.
// Аналогично, в функции logError мы проверяем, является ли параметр err массивом,
// чтобы корректно обработать его содержимое.
// В функции logObject мы используем оператор in для проверки наличия определенного свойства в объекте,
// что позволяет нам безопасно работать с разными структурами данных.
// Таким образом, Union Types в TypeScript предоставляют мощный инструмент
// для создания гибкого и безопасного кода, который может адаптироваться к различным требованиям и сценариям использования.

type statusCode = 200 | 300 | 400 | 500;

function getStatusMessage(code: statusCode): string {
	switch (code) {
		case 200:
			return "Success";
		case 300:
			return "In Progress";
		case 400:
			return "Client Error";
		case 500:
			return "Server Error";
		default:
			return "Unknown Status";
	}
}

console.log(getStatusMessage(200));
console.log(getStatusMessage(400));

// Union Types помогают сделать код более гибким и универсальным,
// позволяя обрабатывать различные типы данных в одной функции или структуре.
// Они обеспечивают безопасность типов, предотвращая ошибки во время выполнения программы,
// и делают код более адаптивным к различным сценариям использования.