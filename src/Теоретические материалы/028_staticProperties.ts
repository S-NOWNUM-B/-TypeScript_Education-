// ===== Статические свойства =====

// Статические свойства принадлежат классу, а не его экземплярам. Они могут быть доступны без создания экземпляра класса.

class MyClass {
	static staticProperty: string = "Это статическое свойство";

	static staticMethod() {
		console.log("Это статический метод");
	}
}

// Доступ к статическому свойству и методу
console.log(MyClass.staticProperty); // Вывод: Это статическое свойство
MyClass.staticMethod(); // Вывод: Это статический метод

// Создание экземпляра класса не влияет на доступ к статическим свойствам и методам
const myInstance = new MyClass();
console.log(MyClass.staticProperty); // Вывод: Это статическое свойство
MyClass.staticMethod(); // Вывод: Это статический метод

// Статические свойства и методы могут быть полезны для хранения общих данных или функциональности, которая не зависит от конкретного экземпляра класса.

// Важно отметить, что статические свойства и методы не могут быть доступны через экземпляры класса, они доступны только через сам класс.
// Например, следующий код вызовет ошибку:
// console.log(myInstance.staticProperty); // Ошибка: Property 'staticProperty' does not exist on type 'MyClass'.
// myInstance.staticMethod(); // Ошибка: Property 'staticMethod' does not exist on type 'MyClass'.

class Counter {
	private static count: number = 0; // Приватное статическое свойство

	public static increment() {
		Counter.count++; // Увеличиваем счетчик
	}

	public static getCount(): number {
		return Counter.count; // Получаем текущее значение счетчика
	}
}

// Использование статических методов для управления счетчиком
Counter.increment();
Counter.increment();
console.log(Counter.getCount()); // Вывод: 2

// В этом примере мы создали класс Counter с приватным статическим свойством count, которое хранит текущее значение счетчика. Мы также создали два публичных статических метода: increment для увеличения счетчика и getCount для получения текущего значения счетчика. Поскольку count является приватным, он не может быть доступен напрямую из-за пределов класса, но мы можем управлять им через публичные статические методы.

class MathUtils {
	static PI: number = 3.14159; // Статическое свойство для хранения значения π

	static calculateCircleArea(radius: number): number {
		return MathUtils.PI * radius * radius; // Используем статическое свойство PI для расчета площади круга
	}

		// Статический метод для расчета площади круга с помощью формулы A = πr²
	static {
		console.log("Статический блок инициализации выполнен");
	}
}

// Доступ к статическому свойству и методу
console.log(MathUtils.PI); // Вывод: 3.14159
console.log(MathUtils.calculateCircleArea(5)); // Вывод: 78.53975

// В этом примере мы создали класс MathUtils с статическим свойством PI, которое хранит значение π, и статическим методом calculateCircleArea, который использует это свойство для расчета площади круга. Мы также добавили статический блок инициализации, который выполняется при загрузке класса и выводит сообщение в консоль.

// пример static async:

class DataFetcher {
	static async fetchData(url: string): Promise<any> {
		try {
			const response = await fetch(url); // Выполняем асинхронный запрос к указанному URL
			if (!response.ok) {
				throw new Error(`Ошибка HTTP: ${response.status}`); // Обработка ошибок HTTP
			}
			const data = await response.json(); // Парсим ответ как JSON
			return data; // Возвращаем полученные данные
		} catch (error) {
			console.error("Ошибка при загрузке данных:", error); // Логируем ошибку в консоль
			throw error; // Пробрасываем ошибку дальше
		}
	}
}

// Использование статического асинхронного метода для получения данных
DataFetcher.fetchData("https://jsonplaceholder.typicode.com/todos/1")
	.then(data => console.log("Полученные данные:", data)) // Выводим полученные данные в консоль
	.catch(error => console.error("Ошибка при получении данных:", error)); // Логируем ошибку при получении данных

// В этом примере мы создали класс DataFetcher с статическим асинхронным методом fetchData, который выполняет HTTP-запрос к указанному URL и возвращает полученные данные в формате JSON. Мы также обрабатываем возможные ошибки, которые могут возникнуть при выполнении запроса, и логируем их в консоль.
// Статические свойства и методы являются мощными инструментами для организации кода и управления общими данными или функциональностью, которая не зависит от конкретных экземпляров класса. Они позволяют создавать утилитарные классы, которые могут быть использованы без необходимости создавать объекты, что может быть полезно в различных сценариях программирования.